#X3D V3.2 utf8
PROFILE Interactive

# Since Blender -> X3D exporter is not perfect (we cannot express in Blender
# everything we want, in a way we want) we add some X3D nodes by hand.
# We use "classic X3D encoding" for this (x3dv extension),
# since this is just easier to read/write for humans (contrast this with
# "example_level.x3d" that was generated by Blender and uses "XML X3D encoding",
# extension x3d).
#
# See X3D specification for the meaning of all nodes/fields inside.
# Right now, the most important and current is
# the "X3D Architecture and base components Edition 2",
# see http://www.web3d.org/files/specifications/19775-1/V3.2/index.html
# (and see http://www.web3d.org/x3d/specifications/ for all VRML/X3D specs list).


# You can embed one X3D file within another using the "Inline" node,
# this way example_level_final.x3dv contains
# the example_level.x3d (generated by Blender) + some of our customizations.
Inline { url "example_level.x3d" }

# Defines various information about avatar (player).
NavigationInfo {
  headlight FALSE
  type "WALK"

  # avatarSize is a list of floats:
  #
  # - collision sphere radius (Camera.Radius in our engine).
  #   If this is not specified (or zero), we will automatically calculate
  #   something hopefully sensible based on level size.
  #
  # - height above the terrain, used only when gravity works
  #   (Camera.PreferredHeight in our engine).
  #   If this is not specified, we will automatically calculate it based
  #   on Camera.Radius, and we always correct it (as this must be > Camera.Radius
  #   for things to work sensibly, preferably > Camera.Radius * 2 to also work
  #   with crouching, head bobbing etc.)
  #
  # - (not specified here) tallest object that you can climb, like a stair step
  #   (Camera.ClimbHeight in our engine).
  #   If not specified (or zero), there is no such limit, and you can climb
  #   very steep (but not vertical) slopes.
  avatarSize [ 0.5, 2 ]

  # speed is in units per second. This is Camera.MoveSpeed in our engine.
  speed 10
}

# Viewpoint defines initial player position/orientation when starting the level.
# I usually define it by navigating in view3dscene and then using view3dscene
# "Console -> Print Current Camera (Viewpoint) (VRML 2.0, X3D classic)".
# But you could also define it by setting camera in Blender
# (make sure in this case that you copy the Viewpoint node to this file,
# as bindable nodes like Viewpoint/NavigationInfo are ignored in Inline files).
#
# Camera settings "encoded" in the VRML/X3D declaration below :
# direction 0.6287420392036438 -4.3711303021609638E-008 0.7776139378547668
# up 9.6099803670313122E-008 1 -7.770189114353343E-008
# gravityUp 0 1 0
Viewpoint {
  position -16.827529907226563 2.0961356163024902 3.8136968612670898
  orientation -6.9521838952368853E-008 -0.9999999403953552 0 2.461658239364624
}

# Add water.
# Water is modeled in the same Blender example_level.blend file,
# but on a layer invisible by default.
# But we export water to a separate X3D file, to wrap it inside Collision
# node with enabled=FALSE, to make water surface not collidable.
# In the future we hope there will be a way to set objects non-collidable
# from Blender.
Collision {
  enabled FALSE
  children Inline { url "water.x3d" }
}

# Textured background.
Background {
  backUrl "sky/sky_back.png"
  bottomUrl "sky/sky_bottom.png"
  frontUrl "sky/sky_front.png"
  leftUrl "sky/sky_left.png"
  rightUrl "sky/sky_right.png"
  topUrl "sky/sky_top.png"
}

# Examples how to add a light source that casts shadows.
# SpotLight {
#   location 0 55 44
#   direction 0 -1 0
#   cutOffAngle 1
#
#   # Uncomment lines below to get shadow by shadow maps.
#   # See http://castle-engine.sourceforge.net/x3d_extensions_shadow_maps.php
#   # for a full documentation.
#   # In a very trivial cases, it's enough to just say "shadows TRUE",
#   # although you may want to adjust other settings.
#
#   # projectionNear 40
#   # projectionFar 60
#   # shadows TRUE
#   # defaultShadowMap GeneratedShadowMap {
#   #   size 4096
#   #   update "ALWAYS"
#   #   bias 4
#   #   scale 4
#   # }
#
#   # Uncomment lines below to get shadow by shadow volumes.
#   # See http://castle-engine.sourceforge.net/x3d_extensions.php#section_ext_shadows .
#   # There are advantages and disadvantages to both shadow approaches.
#   # Also our shadow volumes implementation is a little limited now: only 1 light.
#   # Only 2-manifold objects cast shadows by shadow volumes, which include
#   # only medkit and shooting_eye items right now.
#   # Remember to add "Window.StencilBits := 8;" before "Window.Open;"
#   # if you want to use shadow volumes.
#
#   # shadowVolumesMain TRUE
#   # shadowVolumes TRUE
# }

# Just a test that VRML/X3D events, touch sensors, and CastleScript work fine inside a level.
# Transform {
#   translation 0 10 0
#   scale 0.5 0.5 0.5
#   children Inline { url "../../../../../demo-models/sensors_pointing_device/touch_sensor_tests.x3dv" }
# }
# Transform {
#   rotation 1 0 0 -1.5707963705062866
#   translation 10 10 0
#   scale 0.5 0.5 0.5
#   children Inline { url "../../../../../demo-models/castle_script/particles.x3dv" }
# }
